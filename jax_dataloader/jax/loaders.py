# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/loader.jax.ipynb.

# %% ../../nbs/loader.jax.ipynb 3
from __future__ import print_function, division, annotations
from ..imports import *
from ..datasets import ArrayDataset
from ..loaders import BaseDataLoader
from ..utils import get_config
from ..tests import *
from threading import Thread, Event
from queue import Queue

# %% auto 0
__all__ = ['chunk', 'EpochIterator', 'MultiprocessIterator']

# %% ../../nbs/loader.jax.ipynb 5
def chunk(seq: Sequence, size: int) -> List[Sequence]:
    return [seq[pos:pos + size] for pos in range(0, len(seq), size)]  


# %% ../../nbs/loader.jax.ipynb 6
def EpochIterator(
    data,
    batch_size: int,
    indices: Sequence[int]
):
    for i in range(0, len(indices), batch_size):
        idx = indices[i:i+batch_size]
        yield data[idx]

# %% ../../nbs/loader.jax.ipynb 7
class MultiprocessIterator(Thread):
    """[WIP] Multiprocessing Epoch Iterator"""
    def __init__(self, data, batch_size: int, indices=None):
        super().__init__()
        self.data = data
        indices = np.arange(len(data)) if indices is None else indices
        batches = chunk(indices, batch_size)
        self.iter_idx = iter(batches)
        self.output_queue = Queue() # TODO: maxsize
        self.terminate_event = Event()
        self.start()

    def run(self):
        try:
            while True:
                result = self.get_data()
                self.output_queue.put(result)
        except StopIteration:
            self.output_queue.put(None)

    def __next__(self):
        result = self.output_queue.get()
        if result is None:
            self.close()
            raise StopIteration()
        return result
    
    def __iter__(self):
        return self
    
    def __del__(self):
        self.close()

    def close(self):
        self.terminate_event.set()

    def get_data(self):
        batch_idx = next(self.iter_idx)
        batch = self.data[batch_idx]
        return batch

