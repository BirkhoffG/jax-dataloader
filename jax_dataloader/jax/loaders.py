# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/loader.jax.ipynb.

# %% ../../nbs/loader.jax.ipynb 3
from __future__ import print_function, division, annotations
from ..imports import *
from ..datasets import ArrayDataset
from ..loaders import BaseDataLoader
from ..utils import get_config
from ..tests import *
from threading import Thread, Event
from queue import Queue

# %% auto 0
__all__ = ['chunk', 'EpochIterator']

# %% ../../nbs/loader.jax.ipynb 4
def chunk(seq: Sequence, size: int):
    for pos in range(0, len(seq), size):
        yield seq[pos:pos + size]

# %% ../../nbs/loader.jax.ipynb 5
class EpochIterator(Thread):
    def __init__(self, data, batch_size: int, indices=None):
        super().__init__()
        self.data = data
        indices = np.arange(len(data)) if indices is None else indices
        batches = chunk(indices, batch_size)
        self.iter_idx = iter(batches)
        # self.current_slot = 0
        self.output_queue = Queue() # TODO: maxsize
        self.terminate_event = Event()
        self.start()

    def run(self):
        try:
            while True:
                result = self.get_data()
                self.output_queue.put(result)
                # self.current_slot += 1
        except StopIteration:
            self.output_queue.put(None)

    def __next__(self):
        result = self.output_queue.get()
        if result is None:
            self.close()
            raise StopIteration()
        return result
    
    def __iter__(self):
        return self
    
    def __del__(self):
        self.close()

    def close(self):
        self.terminate_event.set()

    def get_data(self):
        batch_idx = next(self.iter_idx)
        batch = self.data[batch_idx]
        return batch
